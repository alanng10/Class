class Tree : Any
{
    maide prusate Bool Init()
    {
        base.Init();
        this.NodeResult : new TreeNodeResult;
        this.NodeResult.Init();

        this.DirectValue : 1;
        return true;
    }

    field prusate Less Less { get { return data; } set { data : value; } }
    field private TreeNode Root { get { return data; } set { data : value; } }
    field private TreeNodeResult NodeResult { get { return data; } set { data : value; } }
    field private Int DirectValue { get { return data; } set { data : value; } }

    maide prusate Bool Ins(var Any index, var Any value)
    {
        inf (index = null)
        {
            return false;
        }

        var TreeNode node;
        node : this.TreeIns(index, value);
        inf (node = null)
        {
            return false;
        }

        this.InsRetrace(node);
        return true;
    }

    maide prusate Bool Rem(var Any index)
    {
        inf (index = null)
        {
            return false;
        }

        var TreeNodeResult k;
        k : this.Node(index);
        inf (~k.HasNode)
        {
            return false;
        }

        var TreeNode node;
        node : k.Node;

        this.TreeRem(node);

        this.RemRetrace(node);
        return true;
    }

    maide prusate Bool Clear()
    {
        this.Root : null;
        return true;
    }

    maide private bool InsRetrace(var TreeNode z)
    {
        var TreeNode x;
        var TreeNode g;
        var TreeNode n;

        var Bool b;
        b : false;

        x : z.Parent;
        while (~b & ~(x = null))
        {
            var Bool ba;
            ba : false;

            var Int direct;

            var Bool bb;
            bb : (z = x.ChildRite);
            inf (bb)
            {
                direct : sign*(0sn1, this.DirectValue);
            }
            inf (~bb)
            {
                direct : this.DirectValue;
            }

            var Bool bc;
            bc : (this.Sign(x.Balance) = sign*(0sn1, direct));
            inf (bc)
            {
                g : x.Parent;

                var Bool baa;
                baa : (this.Sign(z.Balance) = direct);
                inf (baa)
                {
                    n : this.RotateDouble(x, z, direct);
                }
                inf (~baa)
                {
                    n : this.RotateSingle(x, z, direct);
                }
            }
            if (!bc)
            {
                bool bak;
                bak = (this.Sign(x.Balance) == direct);
                if (bak)
                {
                    x.Balance = 0;

                    b = true;
                }
                if (!bak)
                {
                    x.Balance = - direct;

                    z = x;
                    
                    x = z.Parent;

                    ba = true;
                }
            }

            if (!ba)
            {
                if (!b)
                {
                    n.Parent = g;

                    bool bab;
                    bab = (g == null);
                    if (!bab)
                    {
                        bool bac;
                        bac = (x == g.ChildLite);
                        if (bac)
                        {
                            g.ChildLite = n;
                        }
                        if (!bac)
                        {
                            g.ChildRite = n;
                        }
                    }
                    if (bab)
                    {
                        this.Root = n;
                    }
                }

                b = true;
            }
        }

        return true;
    }
}